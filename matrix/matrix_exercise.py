import numpy as np
A = np.arange(1, 5).reshape(2, 2)
B = np.arange(5, 9).reshape(2, 2)

# A = np.arange(1, 9).reshape(2, 2, 2)
# B = np.arange(5, 13).reshape(2, 2, 2)
# print(np.dot(A, B))
print(A)
"""
[[1 2]
 [3 4]]
"""
print(B)
"""
[[5 6]
 [7 8]]
"""
# 矩阵元素相乘: 矩阵对应位置的参数相乘
print(A * B)
print(np.multiply(A, B))
"""
[[ 5 12]
 [21 32]]
"""

# 内积: 矩阵乘法 行 * 列之和
# 只涉及到二维数组时，这三个操作给出相同的结果。更高维度的数组，np.matmul和@提供了广播支持，而np.dot沿最后一个轴的元素和倒数第二个轴的元素进行求和来计算点积。
print(np.dot(A, B))

print(A @ B)
print(np.matmul(A, B))
"""
[[19 22]
 [43 50]]
 
[[[1 2]         [[[ 5  6]             [[[ 19(1*5+2*7)  22]
  [3 4]]          [ 7  8]]              [ 43(3*5+4*7)   50]]
			@                  =
 [[5 6]          [[ 9 10]              [[111 122]
  [7 8]]]         [11 12]]]             [151 166]]]
  
  
[[[1 2]         [[[ 5  6]             [[[[ 19(1*5+2*7)  22]
  [3 4]]          [ 7  8]]               [ 31(1*9+2*11)  34]]
			dot                 =
 [[5 6]          [[ 9 10]               [[ 43  50]
  [7 8]]]         [11 12]]]              [ 71  78]]]

									   [[[ 67  78]
										 [111 122]]

									    [[ 91 106]
										 [151 166]]]]
"""
# 张量积 a⊗b : 每个元素a在矩阵A中与矩阵B相乘，形成结果矩阵的一部分。如果 A 是一个 m x n 矩阵，B 是一个 p x q 矩阵，那么结果是一个 (m*p) x (n*q) 矩阵
print(np.kron(A, B))
"""
[[ 5  6 10 12]
 [ 7  8 14 16]
 [15 18 20 24]
 [21 24 28 32]]
"""
# 叉积 : 得到的向量（或向量数组）垂直于原始两个向量，并且其长度（在没有复数的情况下）等于原始向量组成的平行四边形的面积。
print(np.cross(A, B))
"""
[-4 -4]
"""
# 外积 : 无论输入数组的原始维度如何:结果是一个形状为 (len(A), len(B)) 的二维数组。
print(np.outer(A, B))
"""
[[ 5  6  7  8]
 [10 12 14 16]
 [15 18 21 24]
 [20 24 28 32]]
"""
